field child: Ref
field rest: Ref
field val: Int
field children: Ref

inline predicate tree(this: Ref)
{
  acc(this.val) && acc(this.children) && list(this.children)
}

inline predicate list(this: Ref)
{
  this == null || cons(this)
}

inline predicate cons(this: Ref)
{
  acc(this.child) && tree(this.child) && acc(this.rest) && list(this.rest)
}

inline predicate all_trees(t1: Ref, t2: Ref, t3: Ref)
{
  tree(t1) && tree(t2) && tree(t3)
}

function tree_sum(this: Ref): Int
  requires acc(tree(this), 1/2)
{
  unfolding tree(this) in this.val + list_sum(this.children)
}

function list_sum(this: Ref): Int
  requires acc(list(this), 1/2)
{
  unfolding list(this) in
    (this == null ? 0 :
      unfolding cons(this) in
        tree_sum(this.child) + list_sum(this.rest))
}
